<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Marching Squares Algorithm</title>
    <link rel="stylesheet" type="text/css" href="semantic/dist/semantic.min.css">
    <link rel="stylesheet" href="style.css" type="text/css">
    <script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
    <script src="semantic/dist/semantic.min.js"></script>
    <script id="vertex" type="x-shader">
      attribute vec2 aVertexPosition;

      void main() {
         gl_Position = vec4(aVertexPosition, 0.0, 1.0);
      }
    </script>
    <script id="fragment" type="x-shader">
      #ifdef GL_ES
        precision highp float;
      #endif

      uniform vec4 uColor;

      void main() {
        gl_FragColor = uColor;
      }
    </script>
    <script type="text/javascript">
      function init(){
        canvas = document.getElementById("mycanvas");

        var desiredWidthInCSSPixels = 800;
        var desiredHeightInCSSPixels = 500;

        // set the display size of the canvas.
        canvas.style.width = desiredWidthInCSSPixels + "px";
        canvas.style.height = desiredHeightInCSSPixels + "px";

        // set the size of the drawingBuffer
        devicePixelRatio = window.devicePixelRatio || 1;
        canvas.width = desiredWidthInCSSPixels * devicePixelRatio;
        canvas.height = desiredHeightInCSSPixels * devicePixelRatio;

        gl = canvas.getContext("webgl");


        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.13, 0.15, 0.17, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // compile shaders into DOM
        var v = document.getElementById("vertex").firstChild.nodeValue;
        var f = document.getElementById("fragment").firstChild.nodeValue;

        var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, v);
        gl.compileShader(vs);

        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, f);
        gl.compileShader(fs);

        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        // Make sure the shaders were correctly compiled
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
          console.log(gl.getShaderInfoLog(vs));
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
          console.log(gl.getShaderInfoLog(fs));
        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
          console.log(gl.getProgramInfoLog(program));

        animate(canvas.height * devicePixelRatio);
      }
      function drawPointOff(x,y,size, one){
        var point = {
          x: (x / canvas.width * devicePixelRatio) - 1,
          y: (y / canvas.height * devicePixelRatio) - 1,
        }
        var aspect = canvas.width / canvas.height;

        var width = size/canvas.width * devicePixelRatio;
        var height = size/canvas.height * devicePixelRatio;

        var vertices = new Float32Array([
          -width + point.x, width * aspect + point.y, 0,  // Line 1
          width + point.x, width * aspect + point.y, 0,
          width + point.x, width * aspect + point.y, 0,   // Line 2
          width + point.x, -width * aspect + point.y, 0,
          width + point.x, -width * aspect + point.y, 0, // Line 3
          -width + point.x, -width * aspect + point.y, 0,
          -width + point.x, -width * aspect + point.y, 0,   // Line 4
          -width + point.x, width * aspect + point.y, 0
        ]);

        vbuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        itemSize = 3;
        numItems = vertices.length / itemSize;


        gl.useProgram(program);

        program.uColor = gl.getUniformLocation(program, "uColor");
        if(one)
          gl.uniform4fv(program.uColor, [1, 0, 0, 1.0]);
        else
          gl.uniform4fv(program.uColor, [0.3216, 0.6157, 0.7176, 1.0]);

        program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(program.aVertexPosition);
        gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.LINES, 0, numItems);
      }


      function drawPointOn(x,y,size){
        var point = {
          x: (x / canvas.width * devicePixelRatio) - 1,
          y: (y / canvas.height * devicePixelRatio) - 1,
        }
        var aspect = canvas.width / canvas.height;

        var width = size/canvas.width * devicePixelRatio;
        var height = size/canvas.height * devicePixelRatio;

        var vertices = new Float32Array([
          point.x - width, point.y - width * aspect,  // L
          point.x + width, point.y - width * aspect,
          point.x + width, point.y + width * aspect,

          point.x + width, point.y + width * aspect,  // L
          point.x - width, point.y + width * aspect,
          point.x - width, point.y - width * aspect
        ]);

        vbuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        itemSize = 2;
        numItems = vertices.length / itemSize;


        gl.useProgram(program);

        program.uColor = gl.getUniformLocation(program, "uColor");
        gl.uniform4fv(program.uColor, [0.6, 1, 1, 1.0]);

        program.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(program.aVertexPosition);
        gl.vertexAttribPointer(program.aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, numItems);
      }
      function animate(height){
        gl.clearColor(0.13, 0.15, 0.17, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        var dist = 30;
        var offset = 40;
        var size = 30;
        // ********************
        // GET RID OF THIS
        // HARDCODED RUBBISH!!!
        height = 1000;
        // ASAP
        // ********************
        var data = generateData(size, 5);

        var $dataContainer = $('#data_container');
        for(var y = 0; y < size; y++){
          for(var x = 0; x < size; x++){
            $dataContainer.append(data[y*size + x]);
          }
          $dataContainer.append("<br>");
        }




        for(var x = 0; x < size; x++){
          for(var y = 0; y < size; y++){


            /*
              We minus the y value off the height to reverse the axes
              putting it inline with css coordinate system.
            */
            if(data[y*size + x] === 0)
              drawPointOff(x*dist+offset, height-(y*dist+offset), 5);
            else
              drawPointOn(x*dist+offset, height-(y*dist+offset), 5);
          }
        }
      }

      function generateData(size, edge){
        count = 0;
        var data = Array.apply(null, Array(size*size)).map(function() { return 1 });
        for(var x = 0; x < size; x++){
          for(var y = 0; y < size; y++){
            if(y === 0 || y === size - 1 ||x === 0 || x === size - 1)
              data[y * size + x] = 0;
          }
        }

        for(var i = 0; i <= edge; i++){
          for(var x = 0; x < size; x++){
            for(var y = 0; y < size; y++){
              if(data[y * size + x] === 0){
                makeZ(x, y, data, size);
              }
            }
          }
        }

        for(var x = 0; x < size; x++){
          for(var y = 0; y < size; y++){
            if(data[y * size + x] === 1){
              var yup = false;
              for(i = -1; i < 2; i++){
                if(i !== 0){
                  if(data[(y+i) * size + x] === 1)
                    yup = true
                  if(data[y * size + x+i] === 1)
                    yup = true
                }
              }
              if(!yup)
                data[y * size + x] === 0
            }
          }
        }


        console.log(count);

        return data;
      }

      function makeZ(x, y, data, size){
        for(var mx = -1; mx < 2; mx++){
          for(var my = -1; my < 2; my++){
            if(mx+x > -1 && mx+x < size && my+y > -1 && my+y < size)
              if(Math.random() > 0.95)
                data[(y + my) * size + x + mx] = 0;
          }
        }
      }
    </script>
  </head>
  <body onload="init()">
    <div class="ui fixed inverted menu">
      <div class="ui container">
        <a href="#" class="header item">
          Marching Squares
        </a>
      </div>
    </div>
    <div class="ui main container">
      <h1 class="ui header">Marching Squares</h1>
      <div class="ui small steps center aligned">
        <div class="step">
          <i class="file text icon"></i>
          <div class="content">
            <div class="title">Load Data</div>
            <div class="description">Random data to visualise. </div>
          </div>
        </div>
        <div class="disabled step">
          <i class="cube icon"></i>
          <div class="content">
            <div class="title">Binarise</div>
            <div class="description">Get index of each cell.</div>
          </div>
        </div>
        <div class="disabled step">
          <i class="flag icon"></i>
          <div class="content">
            <div class="title">Place Contour</div>
            <div class="description">Assign contours from lookup.</div>
          </div>
        </div>
      </div>
      <div class="positioner">
        <div id="data_container">

        </div>
        <canvas id="mycanvas" width="800" height="500"></canvas>
      </div>
    </div>
  </body>
</html>
